{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#installing","title":"Installing","text":"<pre><code>pip install dimstack\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#interactive-jupyter-notebook","title":"Interactive Jupyter Notebook","text":"<p>Example Notebook</p>"},{"location":"examples/#motor-assembly-textbook-example-chapter-9-through-11-dimensioning-and-tolerancing-handbook-mcgraw-hill","title":"Motor Assembly textbook example, Chapter 9 through 11, Dimensioning and Tolerancing Handbook, McGraw Hill","text":"<pre><code>import dimstack as ds\n\nds.display.mode(\"text\")\n\nm1 = ds.StatisticalDimension(\n    nom=208,\n    tol=ds.tol.SymmetricBilateral(0.036),\n    process_sigma=6,\n    k=0.25,\n    name=\"a\",\n    desc=\"Shaft\",\n)\nm2 = ds.StatisticalDimension(\n    nom=-1.75,\n    tol=ds.tol.UnequalBilateral(0, 0.06),\n    process_sigma=3,\n    name=\"b\",\n    desc=\"Retainer ring\",\n)\nm3 = ds.StatisticalDimension(nom=-23, tol=ds.tol.UnequalBilateral(0, 0.12), process_sigma=3, name=\"c\", desc=\"Bearing\")\nm4 = ds.StatisticalDimension(\n    nom=20,\n    tol=ds.tol.SymmetricBilateral(0.026),\n    process_sigma=3,\n    name=\"d\",\n    desc=\"Bearing Sleeve\",\n)\nm5 = ds.StatisticalDimension(nom=-200, tol=ds.tol.SymmetricBilateral(0.145), process_sigma=3, name=\"e\", desc=\"Case\")\nm6 = ds.BasicDimension(\n    nom=20,\n    tol=ds.tol.SymmetricBilateral(0.026),\n    # process_sigma=3,\n    name=\"f\",\n    desc=\"Bearing Sleeve\",\n)\nm7 = ds.StatisticalDimension(nom=-23, tol=ds.tol.UnequalBilateral(0, 0.12), process_sigma=3, name=\"g\", desc=\"Bearing\")\nitems = [m1, m2, m3, m4, m5, m6, m7]\n\nstack = ds.Stack(title=\"stacks on stacks\", items=items)\n\nstack.show()\nstack.Closed.show()\nstack.WC.show()\nstack.RSS.show()\nstack.MRSS.show()\nstack.SixSigma(at=4.5).show()\n\nspec = ds.Spec(\"stack spec\", \"\", dim=stack.SixSigma(at=4.5), LL=0.05, UL=0.8)\nspec.show()\n</code></pre> <p>Returns:</p> <pre><code>Stack: stacks on stacks\nID Name    Description dir  Nom.           Tol. Sen.    Relative Bounds   Dist. Process Sigma    k C_p C_pk       \u03bc       \u03c3 \u03bc_eff   \u03c3_eff Yield Probability Reject PPM\n 0    a          Shaft   + 208.0 \u00b1 0.036           1 [207.964, 208.036]  Normal          \u00b1 6\u03c3 0.25 2.0  1.5 208.009   0.006 208.0   0.008       99.99932047        6.8\n 1    b  Retainer ring   -  1.75 + 0 / - 0.06      1       [1.69, 1.75]  Normal          \u00b1 3\u03c3    0 1.0  1.0    1.72    0.01  1.72    0.01       99.73002039     2699.8\n 2    c        Bearing   -  23.0 + 0 / - 0.12      1        [22.88, 23]  Normal          \u00b1 3\u03c3    0 1.0  1.0   22.94    0.02 22.94    0.02       99.73002039     2699.8\n 3    d Bearing Sleeve   +  20.0 \u00b1 0.026           1   [19.974, 20.026]  Normal          \u00b1 3\u03c3    0 1.0  1.0    20.0 0.00867  20.0 0.00867       99.73002039     2699.8\n 4    e           Case   - 200.0 \u00b1 0.145           1 [199.855, 200.145]  Normal          \u00b1 3\u03c3    0 1.0  1.0   200.0 0.04833 200.0 0.04833       99.73002039     2699.8\n 5    f Bearing Sleeve   +  20.0 \u00b1 0.026           1   [19.974, 20.026] Uniform\n 6    g        Bearing   -  23.0 + 0 / - 0.12      1        [22.88, 23]  Normal          \u00b1 3\u03c3    0 1.0  1.0   22.94    0.02 22.94    0.02       99.73002039     2699.8\n\nDimension: stacks on stacks - Closed Analysis\nID             Name     Description dir Nom.              Tol. Sen. Relative Bounds Distribution\n 7 stacks on stacks Closed Analysis   + 0.25 + 0.533 / - 0.233    1  [0.017, 0.783]      Uniform\n\nDimension: stacks on stacks - WC Analysis\nID             Name Description dir Nom.           Tol. Sen. Relative Bounds Distribution\n 8 stacks on stacks WC Analysis   +  0.4 \u00b1 0.383           1  [0.017, 0.783]      Uniform\n\nWARNING:root:Converting BasicDimension (5: f Bearing Sleeve +20 \u00b1 0.026) to StatisticalDimension\nDimension: stacks on stacks - RSS Analysis (assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)\nID             Name                                                    Description dir Nom.           Tol. Sen.    Relative Bounds Distribution Process Sigma k C_p C_pk   \u03bc       \u03c3 \u03bc_eff   \u03c3_eff Yield Probability Reject PPM\n10 stacks on stacks RSS Analysis (assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)   +  0.4 \u00b1 0.17825         1 [0.22175, 0.57825]       Normal          \u00b1 3\u03c3 0 1.0  1.0 0.4 0.05942   0.4 0.05942       99.73002039     2699.8\n\nWARNING:root:Converting BasicDimension (5: f Bearing Sleeve +20 \u00b1 0.026) to StatisticalDimension\nDimension: stacks on stacks - MRSS Analysis (assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)\nID             Name                                                     Description dir Nom.           Tol. Sen.    Relative Bounds Distribution Process Sigma k     C_p    C_pk   \u03bc       \u03c3 \u03bc_eff   \u03c3_eff Yield Probability Reject PPM\n12 stacks on stacks MRSS Analysis (assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)   +  0.4 \u00b1 0.24046         1 [0.15954, 0.64046]       Normal    \u00b1 3.76693\u03c3 0 1.25564 1.25564 0.4 0.06383   0.4 0.06383       99.98347307     165.27\n\nWARNING:root:Converting BasicDimension (5: f Bearing Sleeve +20 \u00b1 0.026) to StatisticalDimension\nDimension: stacks on stacks - '6 Sigma' Analysis (assuming inputs with Normal Distribution)\nID             Name                                                   Description dir Nom.           Tol. Sen.    Relative Bounds Distribution Process Sigma k C_p C_pk   \u03bc       \u03c3 \u03bc_eff   \u03c3_eff Yield Probability Reject PPM\n14 stacks on stacks '6 Sigma' Analysis (assuming inputs with Normal Distribution)   +  0.4 \u00b1 0.26433         1 [0.13567, 0.66433]       Normal        \u00b1 4.5\u03c3 0 1.5  1.5 0.4 0.05874   0.4 0.05874       99.99932047        6.8\n\nWARNING:root:Converting BasicDimension (5: f Bearing Sleeve +20 \u00b1 0.026) to StatisticalDimension\nSpec: stack spec\n      Name Description                                                                                                        Dimension Spec. Limits Median       k     C_p    C_pk Yield Probability Reject PPM\nstack spec             16: stacks on stacks '6 Sigma' Analysis (assuming inputs with Normal Distribution) +0.4 \u00b1 0.26433 @ \u00b1 4.5\u03c3 &amp; k=0  [0.05, 0.8]  0.425 0.06667 2.12804 1.98617               100          0\n\n</code></pre>"},{"location":"examples/#mit-calc-demonstration-analysis","title":"MIT Calc Demonstration Analysis","text":"<p>https://www.mitcalc.com/en/ui/ui_tanalysis1.htm</p> <pre><code>import dimstack\n\n# this test is a copy of MITCalc User Interface diagram\n\nm1 = dimstack.eval.StatisticalDimension(\n    nom=208,\n    tol=dimstack.tolerance.SymmetricBilateral(0.036),\n    process_sigma=6,\n    k=0.25,\n    name=\"a\",\n    desc=\"Shaft\",\n)\nm2 = dimstack.eval.StatisticalDimension(\n    nom=-1.75,\n    tol=dimstack.tolerance.UnequalBilateral(0, 0.06),\n    process_sigma=3,\n    name=\"b\",\n    desc=\"Retainer ring\",\n)\nm3 = dimstack.eval.StatisticalDimension(nom=-23, tol=dimstack.tolerance.UnequalBilateral(0, 0.12), process_sigma=3, name=\"c\", desc=\"Bearing\")\nm4 = dimstack.eval.StatisticalDimension(\n    nom=20,\n    tol=dimstack.tolerance.SymmetricBilateral(0.026),\n    process_sigma=3,\n    name=\"d\",\n    desc=\"Bearing Sleeve\",\n)\nm5 = dimstack.eval.StatisticalDimension(nom=-200, tol=dimstack.tolerance.SymmetricBilateral(0.145), process_sigma=3, name=\"e\", desc=\"Case\")\nm6 = dimstack.eval.StatisticalDimension(\n    nom=20,\n    tol=dimstack.tolerance.SymmetricBilateral(0.026),\n    process_sigma=3,\n    name=\"f\",\n    desc=\"Bearing Sleeve\",\n)\nm7 = dimstack.eval.StatisticalDimension(nom=-23, tol=dimstack.tolerance.UnequalBilateral(0, 0.12), process_sigma=3, name=\"g\", desc=\"Bearing\")\nitems = [m1, m2, m3, m4, m5, m6, m7]\n\nstack = dimstack.eval.Stack(title=\"stacks on stacks\", items=items)\n\nstack.show()\nstack.Closed.show()\nstack.WC.show()\nstack.RSS.show()\nstack.MRSS.show()\nstack.SixSigma(at=4.5).show()\n</code></pre> <p>Returns:</p> <pre><code>Stack: stacks on stacks\nID Name                     Description dir  Nom.             Tol. Sen. Relative Bounds Distribution Process Sigma k C_p C_pk \u03bc \u03c3 \u03bc_eff \u03c3_eff Yield Probability Reject PPM\n 0    A             Screw thread length   - 0.375   + 0 / - 0.031     1  [0.344, 0.375]      Uniform\n 1    B                   Washer Length   + 0.032   \u00b1 0.002           1   [0.03, 0.034]      Uniform\n 2    C Inner bearing cap turned length   +  0.06   \u00b1 0.003           1  [0.057, 0.063]      Uniform\n 3    D                  Bearing length   + 0.438   + 0 / - 0.015     1  [0.423, 0.438]      Uniform\n 4    E            Spacer turned length   +  0.12   \u00b1 0.005           1  [0.115, 0.125]      Uniform\n 5    F                    Rotor length   +   1.5 + 0.01 / - 0.004    1   [1.496, 1.51]      Uniform\n 4    G            Spacer turned length   +  0.12   \u00b1 0.005           1  [0.115, 0.125]      Uniform\n 3    H                  Bearing length   + 0.438   + 0 / - 0.015     1  [0.423, 0.438]      Uniform\n 6    I           Pulley casting length   +  0.45   \u00b1 0.007           1  [0.443, 0.457]      Uniform\n 7    J             Shaft turned length   - 3.019   + 0.012 / - 0     1  [3.019, 3.031]      Uniform\n 8    K               Tapped hole depth   +   0.3   \u00b1 0.03            1    [0.27, 0.33]      Uniform\n\nDimension: stacks on stacks - Closed Analysis -\nID                               Name Description dir  Nom.              Tol. Sen. Relative Bounds Distribution\n 9 stacks on stacks - Closed Analysis               + 0.064 + 0.093 / - 0.098    1 [-0.034, 0.157]      Uniform\n\nDimension: stacks on stacks - WC Analysis -\nID                           Name Description dir   Nom.           Tol. Sen. Relative Bounds Distribution\n10 stacks on stacks - WC Analysis               + 0.0615 \u00b1 0.0915          1  [-0.03, 0.153]      Uniform\n\nWARNING:root:Converting BasicDimension (0: A Screw thread length -0.375 + 0 / - 0.031) to StatisticalDimension\nWARNING:root:Converting BasicDimension (1: B Washer Length +0.032 \u00b1 0.002) to StatisticalDimension\nWARNING:root:Converting BasicDimension (2: C Inner bearing cap turned length +0.06 \u00b1 0.003) to StatisticalDimension\nWARNING:root:Converting BasicDimension (3: D Bearing length +0.438 + 0 / - 0.015) to StatisticalDimension\nWARNING:root:Converting BasicDimension (4: E Spacer turned length +0.12 \u00b1 0.005) to StatisticalDimension\nWARNING:root:Converting BasicDimension (5: F Rotor length +1.5 + 0.01 / - 0.004) to StatisticalDimension\nWARNING:root:Converting BasicDimension (4: G Spacer turned length +0.12 \u00b1 0.005) to StatisticalDimension\nWARNING:root:Converting BasicDimension (3: H Bearing length +0.438 + 0 / - 0.015) to StatisticalDimension\nWARNING:root:Converting BasicDimension (6: I Pulley casting length +0.45 \u00b1 0.007) to StatisticalDimension\nWARNING:root:Converting BasicDimension (7: J Shaft turned length -3.019 + 0.012 / - 0) to StatisticalDimension\nWARNING:root:Converting BasicDimension (8: K Tapped hole depth +0.3 \u00b1 0.03) to StatisticalDimension\nDimension: stacks on stacks - RSS Analysis - (assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)\nID                            Name                                       Description dir   Nom.           Tol. Sen.    Relative Bounds Distribution Process Sigma k C_p C_pk      \u03bc       \u03c3  \u03bc_eff   \u03c3_eff Yield Probability Reject PPM\n22 stacks on stacks - RSS Analysis (assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)   + 0.0615 \u00b1 0.03755         1 [0.02395, 0.09905]       Normal          \u00b1 3\u03c3 0 1.0  1.0 0.0615 0.01252 0.0615 0.01252       99.73002039     2699.8\n\nWARNING:root:Converting BasicDimension (0: A Screw thread length -0.375 + 0 / - 0.031) to StatisticalDimension\nWARNING:root:Converting BasicDimension (1: B Washer Length +0.032 \u00b1 0.002) to StatisticalDimension\nWARNING:root:Converting BasicDimension (2: C Inner bearing cap turned length +0.06 \u00b1 0.003) to StatisticalDimension\nWARNING:root:Converting BasicDimension (3: D Bearing length +0.438 + 0 / - 0.015) to StatisticalDimension\nWARNING:root:Converting BasicDimension (4: E Spacer turned length +0.12 \u00b1 0.005) to StatisticalDimension\nWARNING:root:Converting BasicDimension (5: F Rotor length +1.5 + 0.01 / - 0.004) to StatisticalDimension\nWARNING:root:Converting BasicDimension (4: G Spacer turned length +0.12 \u00b1 0.005) to StatisticalDimension\nWARNING:root:Converting BasicDimension (3: H Bearing length +0.438 + 0 / - 0.015) to StatisticalDimension\nWARNING:root:Converting BasicDimension (6: I Pulley casting length +0.45 \u00b1 0.007) to StatisticalDimension\nWARNING:root:Converting BasicDimension (7: J Shaft turned length -3.019 + 0.012 / - 0) to StatisticalDimension\nWARNING:root:Converting BasicDimension (8: K Tapped hole depth +0.3 \u00b1 0.03) to StatisticalDimension\nDimension: stacks on stacks - MRSS Analysis - (assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)\nID                             Name                                       Description dir   Nom.           Tol. Sen.    Relative Bounds Distribution Process Sigma k     C_p    C_pk      \u03bc       \u03c3  \u03bc_eff   \u03c3_eff Yield Probability Reject PPM\n34 stacks on stacks - MRSS Analysis (assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)   + 0.0615 \u00b1 0.04919         1 [0.01231, 0.11069]       Normal    \u00b1 3.22567\u03c3 0 1.07522 1.07522 0.0615 0.01525 0.0615 0.01525       99.87432157    1256.78\n\nWARNING:root:Converting BasicDimension (0: A Screw thread length -0.375 + 0 / - 0.031) to StatisticalDimension\nWARNING:root:Converting BasicDimension (1: B Washer Length +0.032 \u00b1 0.002) to StatisticalDimension\nWARNING:root:Converting BasicDimension (2: C Inner bearing cap turned length +0.06 \u00b1 0.003) to StatisticalDimension\nWARNING:root:Converting BasicDimension (3: D Bearing length +0.438 + 0 / - 0.015) to StatisticalDimension\nWARNING:root:Converting BasicDimension (4: E Spacer turned length +0.12 \u00b1 0.005) to StatisticalDimension\nWARNING:root:Converting BasicDimension (5: F Rotor length +1.5 + 0.01 / - 0.004) to StatisticalDimension\nWARNING:root:Converting BasicDimension (4: G Spacer turned length +0.12 \u00b1 0.005) to StatisticalDimension\nWARNING:root:Converting BasicDimension (3: H Bearing length +0.438 + 0 / - 0.015) to StatisticalDimension\nWARNING:root:Converting BasicDimension (6: I Pulley casting length +0.45 \u00b1 0.007) to StatisticalDimension\nWARNING:root:Converting BasicDimension (7: J Shaft turned length -3.019 + 0.012 / - 0) to StatisticalDimension\nWARNING:root:Converting BasicDimension (8: K Tapped hole depth +0.3 \u00b1 0.03) to StatisticalDimension\nDimension: stacks on stacks - '6 Sigma' Analysis - (assuming inputs with Normal Distribution)\nID                                  Name                                Description dir   Nom.           Tol. Sen.    Relative Bounds Distribution Process Sigma k C_p C_pk      \u03bc       \u03c3  \u03bc_eff   \u03c3_eff Yield Probability Reject PPM\n46 stacks on stacks - '6 Sigma' Analysis (assuming inputs with Normal Distribution)   + 0.0615 \u00b1 0.05617         1 [0.00533, 0.11767]       Normal        \u00b1 4.5\u03c3 0 1.5  1.5 0.0615 0.01248 0.0615 0.01248       99.99932047        6.8\n</code></pre>"},{"location":"API_Reference/Dimension/","title":"Dimension","text":""},{"location":"API_Reference/Dimension/#dimstack.eval.BasicDimension","title":"<code>dimstack.eval.BasicDimension</code>","text":"<p>A measurement is a single measurement of a part.</p> <p>Parameters:</p> Name Type Description Default <code>nom</code> <code>float</code> <p>The nominal value of the measurement. Defaults to 0.</p> required <code>tol</code> <code>Union[SymmetricBilateral, UnequalBilateral]</code> <p>The tolerance of the measurement. Defaults to SymmetricBilateral(0).</p> required <code>a</code> <code>float</code> <p>The sensitivity of the measurement. Defaults to 1. If the nominal value is negative, the sensitivity will be multiplied by a -1                 and the nominal value will be made positive.</p> <code>1</code> <code>name</code> <code>str</code> <p>The name of the measurement. Defaults to \"Dimension\".</p> <code>'Dimension'</code> <code>desc</code> <code>str</code> <p>The description of the measurement. Defaults to \"Dimension\".</p> <code>'Dimension'</code> Source code in <code>src\\dimstack\\eval.py</code> <pre><code>class BasicDimension:\n\"\"\"\n    A measurement is a single measurement of a part.\n\n    Args:\n        nom (float, optional): The nominal value of the measurement. Defaults to 0.\n        tol (Union[SymmetricBilateral, UnequalBilateral], optional): The tolerance of the measurement. Defaults to SymmetricBilateral(0).\n        a (float, optional): The sensitivity of the measurement. Defaults to 1. If the nominal value is negative, the sensitivity will be multiplied by a -1\n                            and the nominal value will be made positive.\n        name (str, optional): The name of the measurement. Defaults to \"Dimension\".\n        desc (str, optional): The description of the measurement. Defaults to \"Dimension\".\n    \"\"\"\n\n    newID = itertools.count().__next__\n\n    def __init__(\n        self,\n        nom: float,\n        tol: Union[SymmetricBilateral, UnequalBilateral],\n        a: float = 1,\n        name: str = \"Dimension\",\n        desc: str = \"Dimension\",\n    ):\n        self.id = BasicDimension.newID()\n        self.dir = sign(nom) * sign(a)\n        self.nominal = abs(nom)\n        self.tolerance = tol\n        self.a = abs(a)\n        self.name = name\n        self.description = desc\n        self.distribution = dist.DIST_UNIFORM\n\n    def __repr__(self) -&gt; str:\n        return f\"BasicDimension({self.nominal}, {repr(self.tolerance)}, {self.a}, {self.name}, {self.description})\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.id}: {self.name} {self.description} {self.direction}{nround(self.nominal)} {str(self.tolerance)}\"\n\n    def _repr_html_(self) -&gt; str:\n        return display_df(self.dict, f\"Dimension: {self.name} - {self.description}\", dispmode=\"plot\")._repr_html_()\n\n    def show(self):\n        return display_df(self.dict, f\"Dimension: {self.name} - {self.description}\")\n\n    @property\n    def dict(self) -&gt; Dict[str, Any]:\n        return [\n            {\n                \"ID\": self.id,\n                \"Name\": self.name,\n                \"Description\": (self.description),\n                \"dir\": self.direction,\n                \"Nom.\": nround(self.nominal),\n                \"Tol.\": (str(self.tolerance)).ljust(14, \" \"),\n                \"Sen.\": str(self.a),\n                \"Relative Bounds\": f\"[{nround(self.lower_rel)}, {nround(self.upper_rel)}]\",\n                \"Distribution\": self.distribution,\n            }\n        ]\n\n    @property\n    def direction(self):\n        if self.dir &gt;= 0:\n            return POSITIVE\n        else:\n            return NEGATIVE\n\n    @property\n    def tolerance_absolute(self):\n        if self.direction == POSITIVE:\n            return self.tolerance\n        elif self.direction == NEGATIVE:\n            return Bilateral(self.tolerance.lower, self.tolerance.upper)\n\n    @property\n    def median(self):\n        return (self.lower_rel + self.upper_rel) / 2\n\n    @property\n    def Z_min(self):\n\"\"\"The minimum value of the measurement. AKA, absolute upper\"\"\"\n        return self.dir * (self.nominal - self.tolerance.lower)\n\n    @property\n    def Z_max(self):\n\"\"\"The maximum value of the measurement. AKA, absolute lower\"\"\"\n        return self.dir * (self.nominal + self.tolerance.upper)\n\n    @property\n    def lower_rel(self):\n        return self.nominal - self.tolerance.lower\n\n    @property\n    def upper_rel(self):\n        return self.nominal + self.tolerance.upper\n\n    def convert_to_bilateral(self):\n        median = self.median\n        tol = self.tolerance.T / 2\n\n        self.nominal = median\n        self.tolerance = SymmetricBilateral(tol)\n        return self\n\n    @classmethod\n    def from_statistical_dimension(\n        cls,\n        stat: \"StatisticalDimension\",\n    ):\n        if type(stat) is BasicDimension:\n            return stat\n\n        logging.warning(f\"Converting StatisticalDimension ({stat}) to BasicDimension\")\n        return cls(\n            nom=stat.nominal * stat.dir,\n            tol=stat.tolerance,\n            a=stat.a,\n            name=stat.name,\n            desc=stat.description,\n        )\n\n    def get_dist(self):\n        return dist.Uniform(self.lower_rel, self.upper_rel)\n\n    def get_alt_dists(self):\n        return []\n</code></pre>"},{"location":"API_Reference/Dimension/#dimstack.eval.BasicDimension.Z_min","title":"<code>Z_min</code>  <code>property</code>","text":"<p>The minimum value of the measurement. AKA, absolute upper</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.BasicDimension.Z_max","title":"<code>Z_max</code>  <code>property</code>","text":"<p>The maximum value of the measurement. AKA, absolute lower</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.StatisticalDimension","title":"<code>dimstack.eval.StatisticalDimension</code>","text":"<p>         Bases: <code>BasicDimension</code></p> <p>StatisticalDimension</p> <p>Parameters:</p> Name Type Description Default <code>process_sigma</code> <code>float</code> <p>The standard deviation of the process represented as \u00b1\u03c3. Defaults to \u00b13\u03c3.</p> <code>3</code> <code>k</code> <code>float</code> <p>The ratio of the amount the center of the distribution is shifted from the mean represented as a multiple of the process                 standard deviation. Defaults to 0\u03c3.</p> <code>0</code> <code>distribution</code> <code>str</code> <p>The distribution of the measurement. Defaults to \"Normal\".</p> <code>dist.DIST_NORMAL</code> Source code in <code>src\\dimstack\\eval.py</code> <pre><code>class StatisticalDimension(BasicDimension):\n\"\"\"StatisticalDimension\n\n    Args:\n        process_sigma (float, optional): The standard deviation of the process represented as \u00b1\u03c3. Defaults to \u00b13\u03c3.\n        k (float, optional): The ratio of the amount the center of the distribution is shifted from the mean represented as a multiple of the process\n                            standard deviation. Defaults to 0\u03c3.\n        distribution (str, optional): The distribution of the measurement. Defaults to \"Normal\".\n    \"\"\"\n\n    def __init__(\n        self,\n        process_sigma: float = 3,\n        k: float = 0,\n        distribution: str = dist.DIST_NORMAL,\n        data=None,\n        *args,\n        **kwargs,\n    ):\n        # super().__init__(*args, **kwargs)\n        super(StatisticalDimension, self).__init__(*args, **kwargs)\n        self.distribution = distribution\n        self.process_sigma = process_sigma\n        self.k = k\n        self.data = data\n\n    def __repr__(self) -&gt; str:\n        return f\"StatisticalDimension({self.nominal}, {repr(self.tolerance)}, {self.a}, {self.name}, {self.description}, {self.process_sigma}, {self.k}, {self.distribution})\"  # noqa: E501\n\n    def __str__(self) -&gt; str:\n        return f\"{self.id}: {self.name} {self.description} {self.direction}{nround(self.nominal)} {str(self.tolerance)} @ \u00b1 {self.process_sigma}\u03c3 &amp; k={self.k}\"\n\n    def _repr_html_(self) -&gt; str:\n        return display_df(self.dict, f\"Dimension: {self.name} - {self.description}\", dispmode=\"plot\")._repr_html_()\n\n    def show(self):\n        return display_df(self.dict, f\"Dimension: {self.name} - {self.description}\")\n\n    @classmethod\n    def from_basic_dimension(\n        cls,\n        basic: Union[BasicDimension, \"StatisticalDimension\"],\n        process_sigma: float = 3,\n        k: float = 0,\n        distribution: str = \"Normal\",\n    ):\n        if type(basic) is StatisticalDimension:\n            return basic\n\n        logging.warning(f\"Converting BasicDimension ({basic}) to StatisticalDimension\")\n        return cls(\n            nom=basic.nominal * basic.dir,\n            tol=basic.tolerance,\n            a=basic.a,\n            name=basic.name,\n            desc=basic.description,\n            process_sigma=process_sigma,\n            k=k,\n            distribution=distribution,\n        )\n\n    @classmethod\n    def from_data(cls, data, sigma=3, name=\"data\", desc=\"data\"):\n\"\"\"Create a StatisticalDimension from data\n\n        Args:\n            data (np.ndarray or similar): The data to create the dimension from\n        \"\"\"\n        distribution = dist.Normal.fit(data)\n\n        return cls(\n            nom=distribution.mean,\n            tol=SymmetricBilateral(distribution.stdev * sigma),\n            a=1,\n            name=name,\n            desc=f\"{desc} (from data)\",\n            process_sigma=sigma,\n            k=0,\n            distribution=dist.DIST_NORMAL,\n            data=data,\n        )\n\n    @property\n    def dict(self) -&gt; Dict[str, Any]:\n        return [\n            {\n                \"ID\": self.id,\n                \"Name\": self.name,\n                \"Description\": (self.description),\n                \"dir\": self.direction,\n                \"Nom.\": nround(self.nominal),\n                \"Tol.\": (str(self.tolerance)).ljust(14, \" \"),\n                \"Sen.\": nround(self.a),\n                \"Relative Bounds\": f\"[{nround(self.lower_rel)}, {nround(self.upper_rel)}]\",\n                \"Distribution\": f\"{self.distribution}\",\n                \"Process Sigma\": f\"\u00b1 {str(nround(self.process_sigma))}\u03c3\",\n                \"k\": nround(self.k),\n                \"C_p\": nround(self.C_p),\n                \"C_pk\": nround(self.C_pk),\n                \"\u03bc\": nround(self.mean),\n                \"\u03c3\": nround(self.stdev),\n                \"\u03bc_eff\": nround(self.mean_eff),\n                \"\u03c3_eff\": nround(self.stdev_eff),\n                \"Yield Probability\": f\"{nround(self.yield_probability*100, 8)}\",\n                \"Reject PPM\": f\"{nround(self.yield_loss_probability*1000000, 2)}\",\n            }\n        ]\n\n    @property\n    def mean(self):\n        mean_shift = self.k * self.process_sigma * self.stdev\n        return self.median + mean_shift\n\n    @property\n    def stdev(self):\n        return abs(self.tolerance.T / 2) / self.process_sigma\n\n    # @property\n    # def variance(self):\n    #     return self.stdev ** 2\n\n    @property\n    def C_p(self):\n        return C_p(self.upper_rel, self.lower_rel, self.stdev)\n\n    @property\n    def C_pk(self):\n        return C_pk(self.upper_rel, self.lower_rel, self.stdev, self.mean)\n\n    @property\n    def mean_eff(self):\n\"\"\"effective mean\"\"\"\n        return (self.lower_rel + self.upper_rel) / 2\n\n    @property\n    def stdev_eff(self):\n\"\"\"\n        effective standard deviation\n        \"6 stdev\" is the standard deviation of the distribution\n        \"\"\"\n        return abs(self.tolerance.T) / (6 * self.C_pk)\n\n    @property\n    def yield_loss_probability(self):\n\"\"\"\n        Returns the probability of a part being out of spec.\n        \"\"\"\n        UL = self.upper_rel\n        LL = self.lower_rel\n        # return 1 - normal_cdf(UL, self.mean_eff, self.stdev_eff) + normal_cdf(LL, self.mean_eff, self.stdev_eff)\n        return 1 - self.get_dist().cdf(UL) + self.get_dist().cdf(LL)\n\n    @property\n    def yield_probability(self):\n        return 1 - self.yield_loss_probability\n\n    def get_dist(self):\n        if self.distribution == dist.DIST_NORMAL:\n            return dist.Normal(self.mean_eff, self.stdev_eff)\n            # return dist.Normal(self.mean, self.stdev)\n        elif self.distribution == dist.DIST_UNIFORM:\n            return dist.Uniform(self.lower_rel, self.upper_rel)\n\n    def get_alt_dists(self):\n        if self.distribution == dist.DIST_NORMAL:\n            if self.k == 0:\n                return []\n            mean_shift = self.k * self.process_sigma * self.stdev\n            return [\n                dist.Normal(self.mean_eff + mean_shift, self.stdev),\n                dist.Normal(self.mean_eff - mean_shift, self.stdev),\n            ]\n        else:\n            return []\n</code></pre>"},{"location":"API_Reference/Dimension/#dimstack.eval.StatisticalDimension.mean_eff","title":"<code>mean_eff</code>  <code>property</code>","text":"<p>effective mean</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.StatisticalDimension.stdev_eff","title":"<code>stdev_eff</code>  <code>property</code>","text":"<p>effective standard deviation \"6 stdev\" is the standard deviation of the distribution</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.StatisticalDimension.yield_loss_probability","title":"<code>yield_loss_probability</code>  <code>property</code>","text":"<p>Returns the probability of a part being out of spec.</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.StatisticalDimension.from_data","title":"<code>from_data(data, sigma=3, name='data', desc='data')</code>  <code>classmethod</code>","text":"<p>Create a StatisticalDimension from data</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>np.ndarray or similar</code> <p>The data to create the dimension from</p> required Source code in <code>src\\dimstack\\eval.py</code> <pre><code>@classmethod\ndef from_data(cls, data, sigma=3, name=\"data\", desc=\"data\"):\n\"\"\"Create a StatisticalDimension from data\n\n    Args:\n        data (np.ndarray or similar): The data to create the dimension from\n    \"\"\"\n    distribution = dist.Normal.fit(data)\n\n    return cls(\n        nom=distribution.mean,\n        tol=SymmetricBilateral(distribution.stdev * sigma),\n        a=1,\n        name=name,\n        desc=f\"{desc} (from data)\",\n        process_sigma=sigma,\n        k=0,\n        distribution=dist.DIST_NORMAL,\n        data=data,\n    )\n</code></pre>"},{"location":"API_Reference/Dimension/#dimstack.eval.Stack","title":"<code>dimstack.eval.Stack</code>","text":"Source code in <code>src\\dimstack\\eval.py</code> <pre><code>class Stack:\n    def __init__(\n        self,\n        title: str = \"Stack\",\n        items: List[Union[BasicDimension, StatisticalDimension]] = [],\n    ):\n        self.title = title\n        self.items = items\n\n    def __repr__(self) -&gt; str:\n        return f\"Stack({self.title}, [{', '.join([repr(item) for item in self.items])}])\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.title}: {self.items}\"\n\n    def _repr_html_(self) -&gt; str:\n        return display_df(self.dict, f\"Stack: {self.title}\", dispmode=\"plot\")._repr_html_()\n\n    def show(self):\n        return display_df(self.dict, f\"Stack: {self.title}\")\n\n    def append(self, measurement: Union[BasicDimension, StatisticalDimension]):\n        self.items.append(measurement)\n\n    @property\n    def Closed(self) -&gt; BasicDimension:\n        nominal = sum([item.nominal * item.a * item.dir for item in self.items])\n        tolerance = Bilateral(\n            sum(filter(None, [item.tolerance_absolute.upper for item in self.items])),\n            sum(filter(None, [item.tolerance_absolute.lower for item in self.items])),\n        )\n        return BasicDimension(\n            nominal,\n            tolerance,\n            name=f\"{self.title} - Closed Analysis\",\n            desc=\"\",\n        )\n\n    @property\n    def WC(self) -&gt; BasicDimension:\n\"\"\"\n        This is a simple WC calculation. This results in a Bilateral dimension with a tolerance that is the sum of the component tolerances.\n        It states that in any combination of tolerances, you can be sure the result will be within the this resulting tolerance.\n        \"\"\"\n        mean = sum([item.median * item.a * item.dir for item in self.items])\n        t_wc = sum([abs(item.a * (item.tolerance.T / 2) * item.dir) for item in self.items])\n        tolerance = Bilateral(t_wc)\n        return BasicDimension(\n            nom=mean,\n            tol=tolerance,\n            name=f\"{self.title} - WC Analysis\",\n            desc=\"\",\n        )\n\n    @property\n    def RSS(self) -&gt; StatisticalDimension:\n\"\"\"\n        This is a simple RSS calculation. This is uses the RSS calculation method in the Dimensioning and Tolerancing Handbook, McGraw Hill.\n        It is really only useful for a Bilateral stack of same process-stdev items. The RSS result has the same uncertainty as the measurements.\n        Historically, Eq. (9.11) assumed that all of the component tolerances (t_i) represent a 3si value for their\n        manufacturing processes. Thus, if all the component distributions are assumed to be normal, then the\n        probability that a dimension is between \u00b1t_i is 99.73%. If this is true, then the assembly gap distribution is\n        normal and the probability that it is \u00b1t_rss between is 99.73%.\n        Although most people have assumed a value of \u00b13s for piecepart tolerances, the RSS equation works\n        for \u201cequal s\u201d values. If the designer assumed that the input tolerances were \u00b14s values for the piecepart\n        manufacturing processes, then the probability that the assembly is between \u00b1t_rss is 99.9937 (4s).\n        The 3s process limits using the RSS Model are similar to the Worst Case Model. The minimum gap is\n        equal to the mean value minus the RSS variation at the gap. The maximum gap is equal to the mean value\n        plus the RSS variation at the gap.\n\n        See:\n         - Dimensioning and Tolerancing Handbook, McGraw Hill\n         - http://files.engineering.com/getfile.aspx?folder=69759f43-e81a-4801-9090-a0c95402bfc0&amp;file=RSS_explanation.GIF\n        \"\"\"\n        items: List[StatisticalDimension] = [StatisticalDimension.from_basic_dimension(item) for item in self.items]\n        d_g = sum([item.mean_eff * item.a * item.dir for item in items])\n        t_rss = RSS_func(*[item.a * (item.tolerance.T / 2) * item.dir for item in items])\n        tolerance = Bilateral(t_rss)\n        return StatisticalDimension(\n            nom=d_g,\n            tol=tolerance,\n            name=f\"{self.title} - RSS Analysis\",\n            desc=\"(assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)\",\n        )\n\n    @property\n    def MRSS(self) -&gt; StatisticalDimension:\n\"\"\"Basically RSS with a coefficient modifier to make the tolerance tighter.\n\n        Returns:\n            StatisticalDimension: _description_\n        \"\"\"\n        items: List[StatisticalDimension] = [StatisticalDimension.from_basic_dimension(item) for item in self.items]\n        d_g = sum([item.mean_eff * item.a * item.dir for item in items])\n        t_wc = sum([abs(item.a * (item.tolerance.T / 2) * item.dir) for item in self.items])\n        t_rss = RSS_func(*[item.a * (item.tolerance.T / 2) * item.dir for item in items])\n        n = len(self.items)\n        C_f = (0.5 * (t_wc - t_rss)) / (t_rss * (n**0.5 - 1)) + 1\n        t_mrss = C_f * t_rss\n        tolerance = Bilateral(t_mrss)\n        stdev = t_wc / 6\n        sigma = t_mrss / stdev\n        return StatisticalDimension(\n            nom=d_g,\n            tol=tolerance,\n            name=f\"{self.title} - MRSS Analysis\",\n            desc=\"(assuming inputs with Normal Distribution &amp; \u00b1 3\u03c3)\",\n            process_sigma=sigma,\n        )\n\n    def SixSigma(self, at: float = 3) -&gt; StatisticalDimension:\n        items: List[StatisticalDimension] = [StatisticalDimension.from_basic_dimension(item) for item in self.items]\n        mean = sum([item.mean_eff * item.dir for item in items])\n        stdev = RSS_func(*[item.stdev_eff for item in items])\n        tolerance = Bilateral(stdev * at)\n        return StatisticalDimension(\n            nom=mean,\n            tol=tolerance,\n            process_sigma=at,\n            name=f\"{self.title} - '6 Sigma' Analysis\",\n            desc=\"(assuming inputs with Normal Distribution)\",\n        )\n\n    @property\n    def dict(self) -&gt; Dict[str, Any]:\n        return [\n            {\n                \"ID\": item.id,\n                \"Name\": item.name,\n                \"Description\": (item.description),\n                \"dir\": item.direction,\n                \"Nom.\": nround(item.nominal),\n                \"Tol.\": (str(item.tolerance)).ljust(14, \" \"),\n                \"Sen.\": f\"{nround(item.a)}\",\n                \"Relative Bounds\": f\"[{nround(item.lower_rel)}, {nround(item.upper_rel)}]\",\n                \"Distribution\": f\"{item.distribution}\" if hasattr(item, \"distribution\") else \"\",\n                \"Process Sigma\": f\"\u00b1 {str(nround(item.process_sigma))}\u03c3\" if hasattr(item, \"process_sigma\") else \"\",\n                \"k\": nround(item.k) if hasattr(item, \"k\") else \"\",\n                \"C_p\": nround(item.C_p) if hasattr(item, \"C_p\") else \"\",\n                \"C_pk\": nround(item.C_pk) if hasattr(item, \"C_pk\") else \"\",\n                \"\u03bc\": nround(item.mean) if hasattr(item, \"mean\") else \"\",\n                \"\u03c3\": nround(item.stdev) if hasattr(item, \"stdev\") else \"\",\n                \"\u03bc_eff\": nround(item.mean_eff) if hasattr(item, \"mean_eff\") else \"\",\n                \"\u03c3_eff\": nround(item.stdev_eff) if hasattr(item, \"stdev_eff\") else \"\",\n                \"Yield Probability\": f\"{nround(item.yield_probability*100, 8)}\" if hasattr(item, \"yield_probability\") else \"\",\n                \"Reject PPM\": f\"{nround(item.yield_loss_probability*1000000, 2)}\" if hasattr(item, \"yield_loss_probability\") else \"\",\n            }\n            for item in self.items\n        ]\n</code></pre>"},{"location":"API_Reference/Dimension/#dimstack.eval.Stack.WC","title":"<code>WC: BasicDimension</code>  <code>property</code>","text":"<p>This is a simple WC calculation. This results in a Bilateral dimension with a tolerance that is the sum of the component tolerances. It states that in any combination of tolerances, you can be sure the result will be within the this resulting tolerance.</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.Stack.RSS","title":"<code>RSS: StatisticalDimension</code>  <code>property</code>","text":"<p>This is a simple RSS calculation. This is uses the RSS calculation method in the Dimensioning and Tolerancing Handbook, McGraw Hill. It is really only useful for a Bilateral stack of same process-stdev items. The RSS result has the same uncertainty as the measurements. Historically, Eq. (9.11) assumed that all of the component tolerances (t_i) represent a 3si value for their manufacturing processes. Thus, if all the component distributions are assumed to be normal, then the probability that a dimension is between \u00b1t_i is 99.73%. If this is true, then the assembly gap distribution is normal and the probability that it is \u00b1t_rss between is 99.73%. Although most people have assumed a value of \u00b13s for piecepart tolerances, the RSS equation works for \u201cequal s\u201d values. If the designer assumed that the input tolerances were \u00b14s values for the piecepart manufacturing processes, then the probability that the assembly is between \u00b1t_rss is 99.9937 (4s). The 3s process limits using the RSS Model are similar to the Worst Case Model. The minimum gap is equal to the mean value minus the RSS variation at the gap. The maximum gap is equal to the mean value plus the RSS variation at the gap.</p> See <ul> <li>Dimensioning and Tolerancing Handbook, McGraw Hill</li> <li>http://files.engineering.com/getfile.aspx?folder=69759f43-e81a-4801-9090-a0c95402bfc0&amp;file=RSS_explanation.GIF</li> </ul>"},{"location":"API_Reference/Dimension/#dimstack.eval.Stack.MRSS","title":"<code>MRSS: StatisticalDimension</code>  <code>property</code>","text":"<p>Basically RSS with a coefficient modifier to make the tolerance tighter.</p> <p>Returns:</p> Name Type Description <code>StatisticalDimension</code> <code>StatisticalDimension</code> <p>description</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.Spec","title":"<code>dimstack.eval.Spec</code>","text":"Source code in <code>src\\dimstack\\eval.py</code> <pre><code>class Spec:\n    def __init__(self, name, description, dim: StatisticalDimension, LL, UL):\n        self.name = name\n        self.description = description\n        self.dim = dim\n        self.LL = LL\n        self.UL = UL\n\n    def __repr__(self) -&gt; str:\n        return f\"Spec({self.name}, {self.description}, {repr(self.dim)}, {self.LL}, {self.UL})\"\n\n    def __str__(self) -&gt; str:\n        return f\"Spec: {self.name}\"\n\n    def _repr_html_(self) -&gt; str:\n        return display_df(self.dict, f\"Spec: {self.name}\", dispmode=\"plot\")._repr_html_()\n\n    def show(self):\n        return display_df(self.dict, f\"Spec: {self.name}\")\n\n    @property\n    def median(self):\n\"\"\"median\"\"\"\n        return (self.LL + self.UL) / 2\n\n    # @property\n    # def mean(self):\n    #     mean_shift = self.k * self.process_sigma * self.stdev\n    #     return self.median + mean_shift\n\n    @property\n    def k(self):\n\"\"\"k\"\"\"\n        return abs((self.dim.mean - self.median) / ((self.UL - self.LL) / 2))\n\n    @property\n    def C_p(self):\n        return C_p(self.UL, self.LL, self.dim.stdev)\n\n    @property\n    def C_pk(self):\n        # return C_pk(self.C_p, self.k)\n        return min(\n            (self.UL - self.dim.mean) / (3 * self.dim.stdev),\n            (self.dim.mean - self.LL) / (3 * self.dim.stdev),\n        )\n\n    @property\n    def yield_loss_probability(self):\n        if self.UL &gt; self.dim.Z_max:\n            upper = 1\n        else:\n            upper = normal_cdf(self.UL, self.dim.mean, self.dim.stdev)\n        if self.LL &lt; self.dim.Z_min:\n            lower = 0\n        else:\n            lower = normal_cdf(self.LL, self.dim.mean, self.dim.stdev)\n        return 1 - (upper - lower)\n\n    @property\n    def yield_probability(self):\n        return 1 - self.yield_loss_probability\n\n    @property\n    def R(self):\n\"\"\"Return the yield loss probability in PPM\"\"\"\n        return self.yield_loss_probability * 1000000\n\n    @property\n    def dict(self) -&gt; Dict[str, Any]:\n        return [\n            {\n                \"Name\": self.name,\n                \"Description\": self.description,\n                \"Dimension\": f\"{self.dim}\",\n                \"Spec. Limits\": f\"[{nround(self.LL)}, {nround(self.UL)}]\",\n                \"Median\": nround(self.median),\n                \"k\": nround(self.k),\n                \"C_p\": nround(self.C_p),\n                \"C_pk\": nround(self.C_pk),\n                \"Yield Probability\": f\"{nround(self.yield_probability*100, 8)}\",\n                \"Reject PPM\": f\"{nround(self.R, 2)}\",\n            }\n        ]\n</code></pre>"},{"location":"API_Reference/Dimension/#dimstack.eval.Spec.median","title":"<code>median</code>  <code>property</code>","text":"<p>median</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.Spec.k","title":"<code>k</code>  <code>property</code>","text":"<p>k</p>"},{"location":"API_Reference/Dimension/#dimstack.eval.Spec.R","title":"<code>R</code>  <code>property</code>","text":"<p>Return the yield loss probability in PPM</p>"},{"location":"API_Reference/Tolerance/","title":"Tolerance","text":""},{"location":"API_Reference/Tolerance/#dimstack.tolerance.Bilateral","title":"<code>dimstack.tolerance.Bilateral(upper, lower=None)</code>","text":"<p>Automatically determine the type of bilateral tolerance to use.</p> <p>Parameters:</p> Name Type Description Default <code>upper</code> <code>float</code> <p>description</p> required <code>lower</code> <code>float</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Tolerance</code> <code>SymmetricBilateral | UnequalBilateral</code> <p>description</p> Source code in <code>src\\dimstack\\tolerance.py</code> <pre><code>def Bilateral(upper: float, lower: float = None):\n\"\"\"Automatically determine the type of bilateral tolerance to use.\n\n    Args:\n        upper (float): _description_\n        lower (float, optional): _description_. Defaults to None.\n\n    Returns:\n        Tolerance (SymmetricBilateral | UnequalBilateral): _description_\n    \"\"\"\n    if lower is None:\n        return SymmetricBilateral(upper)\n    else:\n        if upper == lower:\n            return SymmetricBilateral(upper)\n        else:\n            return UnequalBilateral(upper, lower)\n</code></pre>"},{"location":"API_Reference/Tolerance/#dimstack.tolerance.SymmetricBilateral","title":"<code>dimstack.tolerance.SymmetricBilateral</code>","text":"<p>Bilateral tolerancing is a method of specifying a tolerance that is symmetrical about the nominal value. This is the most common type of tolerancing.</p> Source code in <code>src\\dimstack\\tolerance.py</code> <pre><code>class SymmetricBilateral:\n\"\"\"Bilateral tolerancing is a method of specifying a tolerance that is symmetrical about the nominal value.\n    This is the most common type of tolerancing.\n    \"\"\"\n\n    def __init__(self, tol: float):\n        self._tol = abs(tol)\n\n    def __repr__(self) -&gt; str:\n        return f\"SymmetricBilateral({self._tol})\"\n\n    def __str__(self) -&gt; str:\n        return f\"\u00b1 {nround(self.T/2)}\"\n\n    @property\n    def upper(self):\n        return self._tol\n\n    @property\n    def lower(self):\n        return self._tol\n\n    @property\n    def T(self):\n        return 2 * self._tol\n</code></pre>"},{"location":"API_Reference/Tolerance/#dimstack.tolerance.UnequalBilateral","title":"<code>dimstack.tolerance.UnequalBilateral</code>","text":"<p>Bilateral tolerancing is a method of specifying a tolerance that is asymmetrical about the nominal value. This can also be used for Unilateral tolerancing.</p> Source code in <code>src\\dimstack\\tolerance.py</code> <pre><code>class UnequalBilateral:\n\"\"\"Bilateral tolerancing is a method of specifying a tolerance that is asymmetrical about the nominal value.\n    This can also be used for Unilateral tolerancing.\n    \"\"\"\n\n    def __init__(self, upper: float, lower: float):\n        self.upper = abs(upper)\n        self.lower = abs(lower)\n\n    def __repr__(self) -&gt; str:\n        return f\"UnequalBilateral({self.upper}, {self.lower})\"\n\n    def __str__(self) -&gt; str:\n        return f\"+ {nround(self.upper)} / - {nround(self.lower)}\"\n\n    @property\n    def T(self):\n        return self.upper - self.lower\n</code></pre>"}]}